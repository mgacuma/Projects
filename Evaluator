/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


package expressionevaluator;
import java.util.*;

/**
 *
 * @author Miguel
 */
public class Evaluator {
	private Stack<Operand> opdStack;
	private Stack<Operator> oprStack;
	
	public Evaluator(){
		opdStack = new Stack<Operand>();
		oprStack = new Stack<Operator>();
	}
	
	public int eval(String expr){
                HashMap operators = new HashMap();
                operators.put(("+"), new AdditionOperator());
                operators.put(("-"), new SubtractionOperator());
                operators.put(("*"), new MultiplicationOperator());
                operators.put(("/"), new DivisionOperator());
                operators.put(("#"), new bogusOperator());

		String tok;
                Operator firstOpr = new bogusOperator();
		oprStack.push(firstOpr);
			
		String delimiters = "+_*/#";
		StringTokenizer st = new StringTokenizer(expr, delimiters, true);
		
		while(st.hasMoreTokens()){
			if(!(tok=st.nextToken()).equals(" ")){
                                
                                if(new Operand.check(tok)){
					Operand newOpd = new Operand(tok);
					opdStack.push(newOpd));
				}
				else {
					if(!Operator.check(tok)){
						System.out.println("*****invalid token*****");
						System.exit(1);
					}
				
					Operator newOpr = (Operator) operators.get(tok);
					while(((Operator)oprStack.peek()).priority()>=newOpr.priority()){
						Operator oldOpr = ((Operator)oprStack.pop());
						Operand op2 = (Operand)opdStack.pop();
						Operand op1 = (Operand)opdStack.pop();
						opdStack.push(oldOpr.execute(op1, op2));
					}
					oprStack.push(newOpr);
				}
			}	
		}
	return opdStack.pop().getValue();
        } 
}


class Operand{
	private int value;
	
	public Operand(String tok){
		this.value = Integer.parseInt(tok);	
	}
	
	public Operand(int value){
		this.value = value;
	}

	public boolean check(String tok){
		boolean valid = false;
		try {
			Integer.parseInt(tok);
			valid = true;
		}
		catch (NumberFormatException nfe) {
			System.out.println("*****NFE*****");
		}
		return valid;
	}
	
	public int getValue(){
		return this.value;
	}
}


abstract class Operator{
	
	
	abstract int priority();
	
	boolean check (String tok){
		boolean validTok = false;
		if (tok == "+" || tok == "-" || tok == "*" || tok == "/"){
			validTok = true;
		}
		return validTok;
	}
	
	abstract Operand execute(Operand opd1, Operand opd2);
}


class bogusOperator extends Operator{
        public int priority(){
            return 1;
        }
        
        public Operand execute(Operand opd1, Operand opd2){
            Operand newOpd = new Operand(opd1.getValue()+opd2.getValue());
            return newOpd;
        }
}

class AdditionOperator extends Operator{
	public int priority(){
            return 2;
        }
	
	public Operand execute(Operand opd1, Operand opd2){
		Operand newOpd = new Operand(opd1.getValue() + opd2.getValue());
		return newOpd;
	}
}

class SubtractionOperator extends Operator{
	public int priority(){
            return 2;
        }
	
	public Operand execute(Operand opd1, Operand opd2){
		Operand newOpd = new Operand(opd1.getValue() - opd2.getValue());
		return newOpd;
	}
}

class MultiplicationOperator extends Operator{
	public int priority(){
            return 3;
        }
	
	public Operand execute(Operand opd1, Operand opd2){
		Operand newOpd = new Operand(opd1.getValue() * opd2.getValue());
		return newOpd;
	}
}


class DivisionOperator extends Operator{
	public int priority(){
            return 3;
        }

	public Operand execute(Operand opd1, Operand opd2){
		
                try{
                    Operand newOpd = new Operand(opd1.getValue() / opd2.getValue());
                    return newOpd;
                }
		catch( ArithmeticException dbze){
                    System.out.println("*****DBZE*****");
		}
	return null;	
	}
}
	



	
